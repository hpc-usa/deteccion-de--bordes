# -*- coding: utf-8 -*-
"""procesamiento de bordes img.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g6bV0cAzCcaR4NZ1Yd__eatOPbfyYj91
"""

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import time
from multiprocessing import Pool, cpu_count
import requests
from io import BytesIO

# ============================================================================
# FUNCIONES AUXILIARES
# ============================================================================

def cargar_imagen(url_o_path):
    """Carga una imagen desde URL o path local"""
    try:
        if url_o_path.startswith('http'):
            response = requests.get(url_o_path)
            img = Image.open(BytesIO(response.content))
        else:
            img = Image.open(url_o_path)
        return np.array(img)
    except Exception as e:
        print(f"Error cargando imagen: {e}")
        return None

def rgb_a_escala_grises(imagen_rgb):
    """Convierte imagen RGB a escala de grises"""
    if len(imagen_rgb.shape) == 3:
        # Fórmula estándar de conversión: 0.299*R + 0.587*G + 0.114*B
        return np.dot(imagen_rgb[...,:3], [0.299, 0.587, 0.114]).astype(np.uint8)
    return imagen_rgb

def mostrar_imagenes(imagenes, titulos, figsize=(15, 5)):
    """Muestra múltiples imágenes lado a lado"""
    n = len(imagenes)
    fig, axes = plt.subplots(1, n, figsize=figsize)
    if n == 1:
        axes = [axes]

    for ax, img, titulo in zip(axes, imagenes, titulos):
        if len(img.shape) == 3:
            ax.imshow(img)
        else:
            ax.imshow(img, cmap='gray')
        ax.set_title(titulo)
        ax.axis('off')

    plt.tight_layout()
    plt.show()

# ============================================================================
# ALGORITMO SOBEL SECUENCIAL (CPU - Single Core)
# ============================================================================

def sobel_secuencial(imagen_gris):
    """
    Implementación secuencial del algoritmo Sobel
    """
    # Kernels de Sobel
    Kx = np.array([[-1, 0, 1],
                   [-2, 0, 2],
                   [-1, 0, 1]])

    Ky = np.array([[-1, -2, -1],
                   [ 0,  0,  0],
                   [ 1,  2,  1]])

    filas, columnas = imagen_gris.shape
    imagen_bordes = np.zeros((filas, columnas), dtype=np.float32)

    # Procesar cada pixel (excluyendo bordes de la imagen)
    for i in range(1, filas - 1):
        for j in range(1, columnas - 1):
            # Extraer ventana 3x3 alrededor del pixel
            ventana = imagen_gris[i-1:i+2, j-1:j+2]

            # Calcular Gx (convolución manual)
            Gx = 0
            for ki in range(3):
                for kj in range(3):
                    Gx += ventana[ki, kj] * Kx[ki, kj]

            # Calcular Gy (convolución manual)
            Gy = 0
            for ki in range(3):
                for kj in range(3):
                    Gy += ventana[ki, kj] * Ky[ki, kj]

            # Calcular magnitud del gradiente
            G = np.sqrt(Gx**2 + Gy**2)
            imagen_bordes[i, j] = G

    # Normalizar a rango 0-255
    imagen_bordes = np.clip(imagen_bordes, 0, 255).astype(np.uint8)
    return imagen_bordes

# ============================================================================
# ALGORITMO SOBEL PARALELO (CPU - Multi Core)
# ============================================================================

def procesar_fila_sobel(args):
    """
    Procesa una fila de la imagen con Sobel
    """
    i, imagen_gris, filas, columnas = args

    # Kernels de Sobel
    Kx = np.array([[-1, 0, 1],
                   [-2, 0, 2],
                   [-1, 0, 1]])

    Ky = np.array([[-1, -2, -1],
                   [ 0,  0,  0],
                   [ 1,  2,  1]])

    fila_resultado = np.zeros(columnas, dtype=np.float32)

    # Procesar solo si no es borde
    if i > 0 and i < filas - 1:
        for j in range(1, columnas - 1):
            # Extraer ventana 3x3
            ventana = imagen_gris[i-1:i+2, j-1:j+2]

            # Calcular Gx
            Gx = 0
            for ki in range(3):
                for kj in range(3):
                    Gx += ventana[ki, kj] * Kx[ki, kj]

            # Calcular Gy
            Gy = 0
            for ki in range(3):
                for kj in range(3):
                    Gy += ventana[ki, kj] * Ky[ki, kj]

            # Magnitud del gradiente
            G = np.sqrt(Gx**2 + Gy**2)
            fila_resultado[j] = G

    return i, fila_resultado

def sobel_paralelo(imagen_gris, num_procesos=None):
    """
    Implementación paralela del algoritmo Sobel usando multiprocessing
    """
    if num_procesos is None:
        num_procesos = cpu_count()

    filas, columnas = imagen_gris.shape
    imagen_bordes = np.zeros((filas, columnas), dtype=np.float32)

    # Preparar argumentos para cada fila
    args = [(i, imagen_gris, filas, columnas) for i in range(filas)]

    # Procesar en paralelo
    with Pool(processes=num_procesos) as pool:
        resultados = pool.map(procesar_fila_sobel, args)

    # Ensamblar resultado
    for i, fila in resultados:
        imagen_bordes[i] = fila

    # Normalizar a rango 0-255
    imagen_bordes = np.clip(imagen_bordes, 0, 255).astype(np.uint8)
    return imagen_bordes

# ============================================================================
# FUNCIÓN PRINCIPAL - DEMO
# ============================================================================

def ejecutar_demo(url_imagen=None):
    """
    Ejecuta una demostración completa del algoritmo Sobel
    """
    # Si no se proporciona URL, usar imagen de ejemplo
    if url_imagen is None:
        url_imagen = 'https://raw.githubusercontent.com/opencv/opencv/master/samples/data/lena.jpg'

    print("="*70)
    print("DETECCIÓN DE BORDES CON ALGORITMO SOBEL")
    print("="*70)

    # 1. Cargar imagen
    print("\n1. Cargando imagen...")
    imagen_original = cargar_imagen(url_imagen)
    if imagen_original is None:
        return
    print(f"   ✓ Imagen cargada: {imagen_original.shape}")

    # 2. Convertir a escala de grises
    print("\n2. Convirtiendo a escala de grises...")
    imagen_gris = rgb_a_escala_grises(imagen_original)
    print(f"   ✓ Conversión completada: {imagen_gris.shape}")

    # Mostrar original y escala de grises
    mostrar_imagenes(
        [imagen_original, imagen_gris],
        ['Imagen Original', 'Escala de Grises']
    )

    # 3. Aplicar Sobel Secuencial
    print("\n3. Ejecutando Sobel SECUENCIAL...")
    inicio = time.time()
    bordes_secuencial = sobel_secuencial(imagen_gris)
    tiempo_secuencial = time.time() - inicio
    print(f"   ✓ Tiempo secuencial: {tiempo_secuencial:.4f} segundos")

    # 4. Aplicar Sobel Paralelo
    num_cores = cpu_count()
    print(f"\n4. Ejecutando Sobel PARALELO (usando {num_cores} cores)...")
    inicio = time.time()
    bordes_paralelo = sobel_paralelo(imagen_gris)
    tiempo_paralelo = time.time() - inicio
    print(f"   ✓ Tiempo paralelo: {tiempo_paralelo:.4f} segundos")

    # 5. Calcular Speedup
    speedup = tiempo_secuencial / tiempo_paralelo
    print("\n" + "="*70)
    print("RESULTADOS DE RENDIMIENTO")
    print("="*70)
    print(f"Tiempo Secuencial:  {tiempo_secuencial:.4f} seg")
    print(f"Tiempo Paralelo:    {tiempo_paralelo:.4f} seg")
    print(f"Speedup (S):        {speedup:.2f}x")
    print(f"Cores utilizados:   {num_cores}")
    print("="*70)

    # Mostrar resultados
    mostrar_imagenes(
        [imagen_gris, bordes_secuencial, bordes_paralelo],
        ['Escala de Grises',
         f'Bordes Secuencial\n({tiempo_secuencial:.3f}s)',
         f'Bordes Paralelo\n({tiempo_paralelo:.3f}s)'],
        figsize=(18, 6)
    )

    return {
        'tiempo_secuencial': tiempo_secuencial,
        'tiempo_paralelo': tiempo_paralelo,
        'speedup': speedup,
        'imagen_original': imagen_original,
        'imagen_gris': imagen_gris,
        'bordes_secuencial': bordes_secuencial,
        'bordes_paralelo': bordes_paralelo
    }

# ============================================================================
# EJECUTAR DEMO
# ============================================================================

if __name__ == "__main__":

    resultados = ejecutar_demo()